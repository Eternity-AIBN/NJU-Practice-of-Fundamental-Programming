#include<iostream>
#include<string>
#define single_card 1
#define pair_card 2
#define three_card 3
#define bomb 4
#define three_and_one 5
#define three_and_two 6
#define straight 7
#define consecutive 8
#define plane 9
#define four_and_two 10
#define king_bomb 11
using namespace std;

struct Card  //表示一张扑克牌
{
	string card;  //牌
	int n;  //牌的编号，用于排序
};
struct Card_And_Num  //记录手中所有牌
{
	Card per_card;   //手中有的牌
	int num;      //每张牌有多少张
};
Card opponent[20]; //上家
Card myself[20]; //自己
Card_And_Num deal_myself[20];  //记录手中每张牌及其数量
int n, m; //n表示手中牌，m表示上家下的牌
int sum;  //手中不同的牌的数量

void pre_dispose(Card a[], int num);  //给每张牌一个编号
void sort(Card a[], int num);  //将手中的牌进行排序
int deal_repetition();  //对自己手中重复的牌进行计数,返回处理后牌面类型-1的值
void my_cin();  //输入牌
int judge(Card a[], int num);  //判断对方下的是何种牌型

int same_card(Card a[], int num);  //相同的牌的最大数量

void my_act(int opponent_card);  //依据对方和自身情况判断如何出牌
int find_card(Card oppo_card, int num); 
//在自己的牌中找到大于对方oppo_card牌的num张牌,返回相同的牌中最后一张的位置，找不到则返回-1
void find_pair(int &pair_1, int &pair_2); //在牌中找到两对对子，将其位置放在pair_1和pair_2中，若找不到则位置为-1
int same_card(int num1, int num2);  
//num1表示顺子或连对或飞机的牌数，num2代表牌型，返回顺子或连对或飞机中最小的牌的位置，若无则返回-1
Card plane_last();  //返回对方飞机中最小的牌
int num_of_plane(); //判断对方下了多少飞机

int main()
{
	m = 9;
	while (1)
	{
		for (int i = 0; i < m; ++i)
			cin >> opponent[i].card;
		pre_dispose(opponent, m);
		sort(opponent, m);
		cout << num_of_plane() << endl;
	}
	return 0;
}

void my_cin()
{
	cout << "分别输入自己和对方各有多少牌：";
	cin >> n >> m;
	cout << "自己的牌：";
	for (int i = 0; i < n; ++i)
		cin >> myself[i].card;
	cout << "对方的牌: ";
	for (int i = 0; i < m; ++i)
		cin >> opponent[i].card;
}
void pre_dispose(Card a[], int num)
{
	for (int i = 0; i < num; ++i)
	{
		a[i].n = (int)a[i].card[0];
		switch (a[i].card[0])
		{
		case '1':a[i].n = (int)'9' + 1; break;
		case 'J': {
			if (a[i].card == "J")
				a[i].n = (int)'9' + 2;
			else a[i].n = (int)'9' + 8;
			break;
		}
		case 'Q':a[i].n = (int)'9' + 3; break;
		case 'K':a[i].n = (int)'9' + 4; break;
		case 'A':a[i].n = (int)'9' + 5; break;
		case '2':a[i].n = (int)'9' + 6; break;
		case 'j':a[i].n = (int)'9' + 7; break;
		default:
			break;
		}
	}
}
void sort(Card a[], int num) 
{
	for (int i = num; i>1; --i)
	{
		int max = 0;
		Card tmp;
		for (int j = 1; j< i; ++j)
			if (a[j].n<a[max].n)
				max = j;
		if (max != i - 1)
		{
			tmp = a[i - 1];
			a[i - 1] = a[max];
			a[max] = tmp;
		}
	}
}
int same_card(Card a[], int num)
{
	int num_1 = 1, num_2 = 1;  //num_1用于计数，num_2用于存放最大数量
	for (int i = 0; i < num - 1; ++i)
	{
		if (a[i].card == a[i + 1].card)
			num_1++;
		else {
			if (num_1 > num_2)
				num_2 = num_1;   
			num_1 = 1;  //重新计数
		}
	}
	if (num_1 > num_2)
		num_2 = num_1;
	return num_2;
}
int judge(Card a[], int num)
{
	if (num >= 5 && same_card(a, num) == 1)   //判断是否为顺子
		return straight;
	switch (num)
	{
	case 1:return single_card;  //单张牌
	case 2: {         //两张牌
		if (a[0].card == "JOKER") //王炸
			return king_bomb;
		else return pair_card;  //对子
	}
	case 3:return three_card;  //三张牌不带
	case 4: {
		if (a[0].card == a[3].card)
			return bomb; //四张牌相同，炸弹
		else return three_and_one; //有一张不同，三带一
	}
	case 5: return three_and_two; //三带二
	default: {
		int same_num = same_card(a, num);
		if (same_num == 2)  //连对
			return consecutive;
		else if (same_num == 3)  //飞机
			return plane;
		else return four_and_two;  //四带二
	}
	}
	return 0;
}
int find_card(Card oppo_card, int num)
{
	if (same_card(myself, n) < num)  //手中没有num_of_card张相同的牌
		return -1;
	int i = n - 1;
	for (; i > num - 2; --i)
		if (myself[i].n > oppo_card.n)
		{
			int j = 0;
			for (; j < num - 1; ++j)
				if (myself[i - j].n != myself[i - j - 1].n)break;
			if (j == num - 1)  //手中牌可以压过对方
				return i;
		}
	return -1;
}
void find_pair(int &pair_1, int &pair_2)
{
	int i = 0;
	for (; i < n - 2; ++i)  //寻找第一对对子
		if (myself[i].card == myself[i + 1].card&&myself[i].card != myself[i + 2].card)break;
	if (i < n - 3)  //第一对对子后面还有至少两张牌
		pair_1 = i;
	else return;
	for (; i < n - 2; ++i)  //寻找第二对对子
		if (myself[i].card == myself[i + 1].card&&myself[i].card != myself[i + 2].card)break;
	if (i < n - 2)
		pair_2 = i;
	else if (myself[i].card == myself[i + 1].card) //最后两张牌是一对
			pair_2 = i;
	else return;
}
int deal_repetition()
{
	for (int k = 0; k < 20; ++k)
		deal_myself[k].num = 1;
	int i = 0, j = 0;
	for (; i < n; ++i)
	{
		deal_myself[j].per_card = myself[i];
		if (myself[i].card != myself[i + 1].card)
			++j;
		else deal_myself[j].num++;
	}
	if (myself[i].card != myself[i - 1].card)
	{
		deal_myself[j].per_card = myself[i];
		return j;
	}
	return j - 1;
}
Card plane_last()
{
	int i = m - 1;
	for (; i > 1; --i)
		if (opponent[i].card == opponent[i - 1].card&&opponent[i].card == opponent[i - 2].card)break;
	return opponent[i];
}
int num_of_plane()
{
	int count = 0;
	for (int i = 0; i < m; ++i)
		if (opponent[i].card == opponent[i + 1].card&&opponent[i].card == opponent[i + 2].card)
		{
			count++;
			i = i + 2;
		}
	return count;
}
int same_card(int num1,int num2)
{
	int num = num1 / num2;  //对方下的顺子或对子或飞机的数量
	sum = deal_repetition();
	int i = sum;
	Card tmp; //存放对方牌型中最小的牌
	if (num2 == 3) //对方下的是飞机
		tmp = plane_last();
	else tmp = opponent[m - 1]; //对方下的是顺子或者对子
	for (; deal_myself[i].per_card.card <= tmp.card&&i >= num - 1; --i);
	if (i < num - 1)return -1;  //手中牌无法形成能压住对方的对子
	int count = 1;  //计算顺子or对子or飞机的数量
	for (; i > 0; --i)
	{
		if (deal_myself[i].per_card.n + 1 == deal_myself[i - 1].per_card.n&&deal_myself[i].num>=num2&&deal_myself[i-1].num>=num2)
		{
			count++;
			if (count == num)return i;
		}
		else count = 1;  //重新找顺子
	}
	return -1;
}
void my_act(int opponent_card)
{
	switch (opponent_card)
	{
	case single_card: {
		int i = n - 1;
		for (; i >= 0; --i)
			if (myself[i].n > opponent[0].n)break;
		if (i >= 0)
		{
			cout << myself[i].card << endl;
			return;
		}
		break;
	}
	case pair_card: {
		int flag = find_card(opponent[0], 4);
		if (flag == -1)break;
		for (int k = 0; k < 2; ++k)
			cout << myself[flag - k].card << ' ';
		cout << endl;
		return;
	}
	case three_card: {
		int flag = find_card(opponent[0], 3);
		if (flag == -1)break;
		for (int k = 0; k < 3; ++k)
			cout << myself[flag - k].card << ' ';
		cout << endl;
		return;
	}
	case bomb: {
		int flag = find_card(opponent[0], 4);
		if (flag == -1)break;
		for (int k = 0; k < 4; ++k)
			cout << myself[flag - k].card << ' ';
		cout << endl;
		return;
	}
	case three_and_one: {
		int flag = find_card(opponent[1], 3);  //对方第二张牌一定与其他两张牌相同
		if (flag == -1)break;
		if (flag == n - 1) //自己出的三带是位于最后的几张牌
		{
			cout << myself[0].card << ' ';  //带上第一张牌即可
			for (int k = 0; k < 3; ++k)
				cout << myself[flag - k].card << ' ';
			cout << endl;
		}
		else {
			for (int k = 0; k < 3; ++k)
				cout << myself[flag - k].card << ' ';
			cout << myself[n - 1].card << endl;  //带上最后一张牌
		}
		return;
	}
	case three_and_two: {
		int flag = find_card(opponent[2], 3);//对方第三张牌一定与其他两张牌相同
		if (flag == -1)break;
		if (flag == n - 1) //自己出的三带是位于最后的几张牌
		{
			cout << myself[0].card << ' ' << myself[1].card << ' ';  //带上第一、二张牌即可
			for (int k = 0; k < 3; ++k)
				cout << myself[flag - k].card << ' ';
			cout << endl;
		}
		else {
			cout << myself[0].card << ' '; //带上第一张牌
			for (int k = 0; k < 3; ++k)
				cout << myself[flag - k].card << ' ';
			cout << myself[n - 1].card << endl; //带上最后一张牌
		}
		return;
	}
	case straight: {
		if (opponent[0].card == "2")break; //对方已经连到2
		int last = same_card(m, 1);
		if (last == -1)break;  //未能找到顺子压住对方
		for (int i = 0; i < m; ++i)
			cout << deal_myself[last - i].per_card.card << ' ';
		cout << endl;
		return;
	}
	case consecutive: {
		if (opponent[0].card == "2")break; //对方已经连到2
		int last = same_card(m, 2);
		if (last == -1)break;  //未能找到顺子压住对方
		for (int i = 0; i < m / 2; ++i)
			cout << deal_myself[last - i].per_card.card << ' ' << deal_myself[last - i].per_card.card << ' ';
		cout << endl;
		return;
	}
	case plane: {
		int plane_num = num_of_plane(); //飞机数量
		int additional_card = m - plane_num * 3;  //带的牌数量
		int last = same_card(plane_num * 3, 3);
		if (last == -1)break;  //未能找到顺子压住对方
		if (additional_card / plane_num == 0)  //飞机不带翼
		{
			for (int i = 0; i < plane_num; ++i)
				for (int j = 0; j < 3; ++j)
					cout << deal_myself[last - i].per_card.card << ' ';
		}
		else if (additional_card / plane_num == 1)  //飞机带小翼
		{
			int count = 0;//判断带的牌够了没
			for (int i = 0; i < plane_num; ++i)
				deal_myself[last - i].num -= 3;
			int i = sum;
			for (; i >= last; --i)   //输出带的牌
			{
				for (int j = 0; j < deal_myself[i].num&&count < plane_num; ++j, ++count)
					cout << deal_myself[i].per_card.card << ' ';
				if (count == plane_num)break;
			}
			for (int i = 0; i < plane_num; ++i)  //输出飞机
				for (int j = 0; j < 3; ++j)
					cout << deal_myself[last - i].per_card.card << ' ';
			if (count != plane_num)  //带的牌还不够，继续输出
				for (i = last - plane_num + 1; i >= 0; --i)   //输出带的牌
				{
					for (int j = 0; j < deal_myself[i].num&&count < plane_num; ++j, ++count)
						cout << deal_myself[i].per_card.card << ' ';
					if (count == plane_num)break;
				}
		}
		else if (additional_card / plane_num == 2)  //飞机带大翼
		{
			int count = 0;//判断带的牌够了没
			int i = sum;
			for (; i > last; --i)   //输出带的牌
			{
				if (deal_myself[i].num == 2)
				{
					cout << deal_myself[i].per_card.card << ' ' << deal_myself[i].per_card.card << ' ';
					count++;
				}
				if (count == plane_num)break;
			}
			for (int i = 0; i < plane_num; ++i)  //输出飞机
				for (int j = 0; j < 3; ++j)
					cout << deal_myself[last - i].per_card.card << ' ';
			if (count != plane_num)  //带的牌还不够，继续输出
				for (i = last - plane_num ; i >= 0; --i)   //输出带的牌
				{
					if (deal_myself[i].num == 2)
					{
						cout << deal_myself[i].per_card.card << ' ' << deal_myself[i].per_card.card << ' ';
						count++;
					}
					if (count == plane_num)break;
				}
		}
		cout << endl;
		return;
	}
	case four_and_two: {
		if (m == 6) //对方四带两张牌
		{
			int flag = find_card(opponent[2], 4);
			if (flag == -1)break;
			if (flag == n - 1) //自己出的四带是位于最后的几张牌
			{
				cout << myself[0].card << ' ' << myself[1].card << myself[2].card << endl;  //带上第一、二、三张牌即可
				for (int k = 0; k < 4; ++k)
					cout << myself[flag - k].card << ' ';
				cout << endl;
			}
			else {
				cout << myself[0].card << ' '; //带上第一张牌
				for (int k = 0; k < 4; ++k)
					cout << myself[flag - k].card << ' ';
				cout << myself[n - 1].card << endl; //带上最后一张牌
			}
			return;
		}
		else  //对方四带两对牌
		{
			Card tmp; //存放对方四张相同牌的牌面
			if (opponent[3].card == opponent[4].card)  //四张相同的牌在中间
				tmp = opponent[3];
			else if (opponent[0].card == opponent[1].card)  //前四张牌相同
				tmp = opponent[0];
			else tmp = opponent[4];  //后四张牌相同
			int flag = find_card(tmp, 4);
			if (flag == -1)break;
			int pair_first = -1, pair_second = -1;
			find_pair(pair_first, pair_second);
			if (pair_second == -1)break; //自己手上没有两对对子可以带
			if (pair_first < flag)
			{
				cout << myself[pair_first].card << ' ' << myself[pair_first + 1].card << ' ';
				for (int k = 0; k < 4; ++k)
					cout << myself[flag - k].card << ' ';
				cout << myself[pair_second].card << ' ' << myself[pair_second + 1].card << ' ';
			}
			else {
				for (int k = 0; k < 4; ++k)
					cout << myself[flag - k].card << ' ';
				cout << myself[pair_first].card << ' ' << myself[pair_first + 1].card << ' ';
				cout << myself[pair_second].card << ' ' << myself[pair_second + 1].card << ' ';
			}
			cout << endl;
			return;
		}
	}
	default:
		break;
	}
	if (opponent_card == bomb)  //考虑能否用王炸压过炸弹
	{
		if (myself[0].card == "JOKER"&&myself[1].card == "joker")
			cout << myself[0].card << ' ' << myself[1].card << endl;
		return;
	}
	else {   //考虑能否使用炸弹
		Card tmp;
		tmp.n = -1;
		int flag = find_card(tmp, 4);
		if (flag == -1)
		{
			cout << "YAO BU QI" << endl;
			return;
		}
		for (int k = 0; k < 4; ++k)
			cout << myself[flag - k].card << ' ';
		cout << endl;
		return;
	}
	cout << "YAO BU QI" << endl;
}