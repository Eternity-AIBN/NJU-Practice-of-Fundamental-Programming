#include<iostream>
#include<string>
#define single_card 1
#define pair_card 2
#define three_card 3
#define bomb 4
#define three_and_one 5
#define three_and_two 6
#define straight 7
#define consecutive 8
#define plane 9
#define four_and_two 10
#define king_bomb 11
using namespace std;
struct Card  //表示扑克牌
{
	string card;  //牌
	int n;  //牌的编号，用于排序
};
Card opponent[20]; //上家
Card myself[20]; //自己
int n, m; //n表示手中牌，m表示上家下的牌
void pre_dispose(Card a[], int num);  //给每张牌一个编号
void sort(Card a[], int num);  //将手中的牌进行排序
void my_cin();  //输入牌
int judge(Card a[], int num);  //判断对方下的是何种牌型
int same_card(Card a[], int num);  //相同的牌的最大数量
void my_act(Card a[], int num,int opponent_card);  //依据对方和自身情况判断如何出牌
int find_card(Card a[], int num, Card oppo_card, int num_of_card); 
//在自己的牌中找到大于对方oppo_card牌的num_of_card张牌并输出,返回相同的牌中最后一张的位置，找不到则返回-1

int main()
{
	/*my_cin();
	pre_dispose(myself, n);
	pre_dispose(opponent, m);*/
	/*while (1)
	{
		int nn;
		cout << "输入牌数：";
		cin >> nn;
		cout << "输入牌：";
		for (int i = 0; i < nn; ++i)
			cin >> opponent[i].card;
		pre_dispose(opponent, nn);
		sort(opponent, nn);
		int ans = judge(opponent, nn);
		switch (ans)
		{
		case 1:cout << "single_card" << endl; break;
		case 2:cout << "pair_card" << endl; break;
		case 3:cout << "three_card" << endl; break;
		case 4:cout << "bomb" << endl; break;
		case 5:cout << "three_and_one" << endl; break;
		case 6:cout << "three_and_two" << endl; break;
		case 7:cout << "straight" << endl; break;
		case 8:cout << "consecutive" << endl; break;
		case 9:cout << "plane" << endl; break;
		case 10:cout << "four_and_two" << endl; break;
		case 11:cout << "king_bomb" << endl; break;
		default:
			break;
		}
	}*/ //测试牌型
	while (1)
	{
		my_cin();
		pre_dispose(myself, n);
		pre_dispose(opponent, m);
		sort(myself, n);
		sort(opponent, m);
		cout << "自己的牌排序后：";
		for (int i = 0; i < n; ++i)
			cout << myself[i].card << ' ';
		cout << endl;
		cout << find_card(myself, n, opponent[0], m) << endl;
	}
	return 0;
}

void my_cin()
{
	cout << "分别输入自己和对方各有多少牌：";
	cin >> n >> m;
	cout << "自己的牌：";
	for (int i = 0; i < n; ++i)
		cin >> myself[i].card;
	cout << "对方的牌: ";
	for (int i = 0; i < m; ++i)
		cin >> opponent[i].card;
}
void pre_dispose(Card a[], int num)
{
	for (int i = 0; i < num; ++i)
	{
		a[i].n = (int)a[i].card[0];
		if (a[i].card=="10")
			a[i].n = (int)'9' + 1;
		if (a[i].card == "2")
			a[i].n = (int)'Q' + 3;
		if (a[i].card == "A")
			a[i].n = (int)'Q' + 2;
		if (a[i].card == "K")
			a[i].n = (int)'Q' + 1;
		if (a[i].card == "joker")
			a[i].n = (int)"Q" + 4;
		if (a[i].card == "JOKER")
			a[i].n = (int)"Q" + 5;
	}
}
void sort(Card a[], int num) 
{
	for (int i = num; i>1; --i)
	{
		int max = 0;
		Card tmp;
		for (int j = 1; j< i; ++j)
			if (a[j].n<a[max].n)
				max = j;
		if (max != i - 1)
		{
			tmp = a[i - 1];
			a[i - 1] = a[max];
			a[max] = tmp;
		}
	}
}
int same_card(Card a[], int num)
{
	int num_1 = 1, num_2 = 1;  //num_1用于计数，num_2用于存放最大数量
	for (int i = 0; i < num - 1; ++i)
	{
		if (a[i].card == a[i + 1].card)
			num_1++;
		else {
			if (num_1 > num_2)
				num_2 = num_1;   
			num_1 = 1;  //重新计数
		}
	}
	if (num_1 > num_2)
		num_2 = num_1;
	return num_2;
}
int judge(Card a[], int num)
{
	if (num >= 5 && same_card(a, num) == 1)   //判断是否为顺子
		return straight;
	switch (num)
	{
	case 1:return single_card;  //单张牌
	case 2: {         //两张牌
		if (a[0].card == "JOKER") //王炸
			return king_bomb;
		else return pair_card;  //对子
	}
	case 3:return three_card;  //三张牌不带
	case 4: {
		if (a[0].card == a[3].card)
			return bomb; //四张牌相同，炸弹
		else return three_and_one; //有一张不同，三带一
	}
	case 5: return three_and_two; //三带二
	default: {
		int same_num = same_card(a, num);
		if (same_num == 2)  //连对
			return consecutive;
		else if (same_num == 3)  //飞机
			return plane;
		else return four_and_two;  //四带二
	}
	}
	return 0;
}
int find_card(Card a[], int num, Card oppo_card, int num_of_card)
{
	if (same_card(a, num) < num_of_card)  //手中没有num_of_card张相同的牌
		return -1;
	int i = num - 1;
	for (; i > num_of_card - 2; --i)
		if (a[i].n > oppo_card.n)
		{
			int j = 0;
			for (; j < num_of_card - 1; ++j)
				if (a[i - j].n != a[i - j - 1].n)break;
			if (j == num_of_card - 1)  //手中牌可以压过对方
			{
				for (int k = 0; k < num_of_card; ++k)
					cout << a[i - k].card << ' ';
				return i;
			}
		}
	return -1;
}
void my_act(Card a[], int num, int opponent_card)
{
	switch (opponent_card)
	{
	case single_card: {
		int i = num - 1;
		for (; i >= 0; --i)
			if (a[i].n > opponent[0].n)break;
		if (i >= 0)
		{
			cout << a[i].card << endl;
			return;
		}
		break;
	}
	case pair_card: {
		int flag = find_card(myself, n, opponent[0], 4);
		if (flag == -1)break;
		cout << endl;
		return;
	}
	case three_card: {
		int flag = find_card(myself, n, opponent[0], 3);
		if (flag == -1)break;
		cout << endl;
		return;
	}
	case bomb: {
		int flag = find_card(myself, n, opponent[0], 4);
		if (flag == -1)break;
		cout << endl;
		return;
	}
	case three_and_one: {
		int flag = find_card(myself, n, opponent[1], 3);  //对方第二张牌一定与其他两张牌相同
		if (flag == -1)break;
		if (flag == n - 1) //自己出的三带是位于最后的几张牌
			cout << myself[0].card << endl;  //带上第一张牌即可
		else cout << myself[n - 1].card << endl; //带上最后一张牌
		return;
	}
	case three_and_two: {
		int flag = find_card(myself, n, opponent[2], 3);//对方第三张牌一定与其他两张牌相同
		if (flag == -1)break;
		if (flag == n - 1) //自己出的三带是位于最后的几张牌
			cout << myself[0].card << ' ' << myself[1].card << endl;  //带上第一、二张牌即可
		else cout << myself[0].card << ' ' << myself[n - 1].card << endl; //带上第一张牌和最后一张牌
		return;
	}
	case straight: 
	case consecutive:
	case plane:
	case four_and_two: {
		if (m == 6) //对方四带两张牌
		{
			int flag = find_card(myself, n, opponent[2], 4);
			if (flag == -1)break;
			if (flag == n - 1) //自己出的四带是位于最后的几张牌
				cout << myself[0].card << ' ' << myself[1].card << myself[2].card << endl;  //带上第一、二、三张牌即可
			else cout << myself[0].card << ' ' << myself[n - 1].card << endl; //带上第一张牌和最后一张牌
			return;
		}
		else  //对方四带两对牌
		{
			int flag_1 = find_card(myself, n, opponent[3], 4); //对方第四张牌是否相同的四张牌之一
			if (flag_1 == -1)
			{
				int flag_2 = find_card(myself, n, opponent[4], 4); //对方第五张牌是否相同的四张牌之一
				if (flag_2 == -1)break;

			}
		}
	}
	default:
		break;
	}
	cout << "YAO BU QI" << endl;
}