#include<iostream>
#include<string>
#define single_card 1
#define pair_card 2
#define three_card 3
#define bomb 4
#define three_and_one 5
#define three_and_two 6
#define straight 7
#define consecutive 8
#define plane 9
#define four_and_two 10
#define king_bomb 11
using namespace std;
struct Card  //表示扑克牌
{
	string card;  //牌
	int n;  //牌的编号，用于排序
};
Card opponent[20]; //上家
Card myself[20]; //自己
Card deal_myself[20];  //去除自己手中重复牌后剩下的牌
int locate[20];  //记录顺子的位置
int n, m; //n表示手中牌，m表示上家下的牌
void pre_dispose(Card a[], int num);  //给每张牌一个编号
void sort(Card a[], int num);  //将手中的牌进行排序
void my_cin();  //输入牌
int judge(Card a[], int num);  //判断对方下的是何种牌型
int same_card(Card a[], int num);  //相同的牌的最大数量
void my_act(int opponent_card);  //依据对方和自身情况判断如何出牌
int find_card(Card oppo_card, int num); 
//在自己的牌中找到大于对方oppo_card牌的num张牌,返回相同的牌中最后一张的位置，找不到则返回-1
void find_pair(int &pair_1, int &pair_2); //在牌中找到两对对子，将其位置放在pair_1和pair_2中，若找不到则位置为-1
bool find_straight();  //将组成顺子的牌的位置放在数组中
int del_repetition();  //将自己手中重复的牌去除,返回处理后牌数-1的值

int main()
{
	/*my_cin();
	pre_dispose(myself, n);
	pre_dispose(opponent, m);*/
	/*while (1)
	{
		int nn;
		cout << "输入牌数：";
		cin >> nn;
		cout << "输入牌：";
		for (int i = 0; i < nn; ++i)
			cin >> opponent[i].card;
		pre_dispose(opponent, nn);
		sort(opponent, nn);
		int ans = judge(opponent, nn);
		switch (ans)
		{
		case 1:cout << "single_card" << endl; break;
		case 2:cout << "pair_card" << endl; break;
		case 3:cout << "three_card" << endl; break;
		case 4:cout << "bomb" << endl; break;
		case 5:cout << "three_and_one" << endl; break;
		case 6:cout << "three_and_two" << endl; break;
		case 7:cout << "straight" << endl; break;
		case 8:cout << "consecutive" << endl; break;
		case 9:cout << "plane" << endl; break;
		case 10:cout << "four_and_two" << endl; break;
		case 11:cout << "king_bomb" << endl; break;
		default:
			break;
		}
	}*/ //测试牌型
	
	return 0;
}

void my_cin()
{
	cout << "分别输入自己和对方各有多少牌：";
	cin >> n >> m;
	cout << "自己的牌：";
	for (int i = 0; i < n; ++i)
		cin >> myself[i].card;
	cout << "对方的牌: ";
	for (int i = 0; i < m; ++i)
		cin >> opponent[i].card;
}
void pre_dispose(Card a[], int num)
{
	for (int i = 0; i < num; ++i)
	{
		a[i].n = (int)a[i].card[0];
		switch (a[i].card[0])
		{
		case '1':a[i].n = (int)'9' + 1; break;
		case 'J': {
			if (a[i].card == "J")
				a[i].n = (int)'9' + 2;
			else a[i].n = (int)'9' + 8;
			break;
		}
		case 'Q':a[i].n = (int)'9' + 3; break;
		case 'K':a[i].n = (int)'9' + 4; break;
		case 'A':a[i].n = (int)'9' + 5; break;
		case '2':a[i].n = (int)'9' + 6; break;
		case 'j':a[i].n = (int)'9' + 7; break;
		default:
			break;
		}
	}
}
void sort(Card a[], int num) 
{
	for (int i = num; i>1; --i)
	{
		int max = 0;
		Card tmp;
		for (int j = 1; j< i; ++j)
			if (a[j].n<a[max].n)
				max = j;
		if (max != i - 1)
		{
			tmp = a[i - 1];
			a[i - 1] = a[max];
			a[max] = tmp;
		}
	}
}
int same_card(Card a[], int num)
{
	int num_1 = 1, num_2 = 1;  //num_1用于计数，num_2用于存放最大数量
	for (int i = 0; i < num - 1; ++i)
	{
		if (a[i].card == a[i + 1].card)
			num_1++;
		else {
			if (num_1 > num_2)
				num_2 = num_1;   
			num_1 = 1;  //重新计数
		}
	}
	if (num_1 > num_2)
		num_2 = num_1;
	return num_2;
}
int judge(Card a[], int num)
{
	if (num >= 5 && same_card(a, num) == 1)   //判断是否为顺子
		return straight;
	switch (num)
	{
	case 1:return single_card;  //单张牌
	case 2: {         //两张牌
		if (a[0].card == "JOKER") //王炸
			return king_bomb;
		else return pair_card;  //对子
	}
	case 3:return three_card;  //三张牌不带
	case 4: {
		if (a[0].card == a[3].card)
			return bomb; //四张牌相同，炸弹
		else return three_and_one; //有一张不同，三带一
	}
	case 5: return three_and_two; //三带二
	default: {
		int same_num = same_card(a, num);
		if (same_num == 2)  //连对
			return consecutive;
		else if (same_num == 3)  //飞机
			return plane;
		else return four_and_two;  //四带二
	}
	}
	return 0;
}
int find_card(Card oppo_card, int num)
{
	if (same_card(myself, n) < num)  //手中没有num_of_card张相同的牌
		return -1;
	int i = n - 1;
	for (; i > num - 2; --i)
		if (myself[i].n > oppo_card.n)
		{
			int j = 0;
			for (; j < num - 1; ++j)
				if (myself[i - j].n != myself[i - j - 1].n)break;
			if (j == num - 1)  //手中牌可以压过对方
				return i;
		}
	return -1;
}
void find_pair(int &pair_1, int &pair_2)
{
	int i = 0;
	for (; i < n - 2; ++i)  //寻找第一对对子
		if (myself[i].card == myself[i + 1].card&&myself[i].card != myself[i + 2].card)break;
	if (i < n - 3)  //第一对对子后面还有至少两张牌
		pair_1 = i;
	else return;
	for (; i < n - 2; ++i)  //寻找第二对对子
		if (myself[i].card == myself[i + 1].card&&myself[i].card != myself[i + 2].card)break;
	if (i < n - 2)
		pair_2 = i;
	else if (myself[i].card == myself[i + 1].card) //最后两张牌是一对
			pair_2 = i;
	else return;
}
int del_repetition()
{
	int i = 0, j = 0;
	for (; i < n; ++i)
	{
		deal_myself[j] = myself[i];
		if (myself[i].card != myself[i + 1].card)
			++j;
	}
	if (myself[i].card != myself[i - 1].card)
	{
		deal_myself[j] = myself[i];
		return j;
	}
	return j - 1;
}
bool find_straight()
{
	int last = del_repetition();
	if (last + 1 < m)return false;  //手中牌无法形成能压住对方的顺子
	int i = last;
	for (; deal_myself[i].card <= opponent[m - 1].card&&i >= m - 1; --i);
	if (i < m - 1)return false;  //手中牌无法形成能压住对方的顺子
	int count = 0;  //计算顺子中牌的数量
	for (; i > 0; --i)
	{
		if (deal_myself[i].n + 1 == deal_myself[i - 1].n)
		{
			locate[count] = i;
			count++;
			if (count + 1 == m)return true;
		}
		else count = 0;  //重新找顺子
	}
	return false;
}
void my_act(int opponent_card)
{
	switch (opponent_card)
	{
	case single_card: {
		int i = n - 1;
		for (; i >= 0; --i)
			if (myself[i].n > opponent[0].n)break;
		if (i >= 0)
		{
			cout << myself[i].card << endl;
			return;
		}
		break;
	}
	case pair_card: {
		int flag = find_card(opponent[0], 4);
		if (flag == -1)break;
		for (int k = 0; k < 2; ++k)
			cout << myself[flag - k].card << ' ';
		cout << endl;
		return;
	}
	case three_card: {
		int flag = find_card(opponent[0], 3);
		if (flag == -1)break;
		for (int k = 0; k < 3; ++k)
			cout << myself[flag - k].card << ' ';
		cout << endl;
		return;
	}
	case bomb: {
		int flag = find_card(opponent[0], 4);
		if (flag == -1)break;
		for (int k = 0; k < 4; ++k)
			cout << myself[flag - k].card << ' ';
		cout << endl;
		return;
	}
	case three_and_one: {
		int flag = find_card(opponent[1], 3);  //对方第二张牌一定与其他两张牌相同
		if (flag == -1)break;
		if (flag == n - 1) //自己出的三带是位于最后的几张牌
		{
			cout << myself[0].card << ' ';  //带上第一张牌即可
			for (int k = 0; k < 3; ++k)
				cout << myself[flag - k].card << ' ';
			cout << endl;
		}
		else {
			for (int k = 0; k < 3; ++k)
				cout << myself[flag - k].card << ' ';
			cout << myself[n - 1].card << endl;  //带上最后一张牌
		}
		return;
	}
	case three_and_two: {
		int flag = find_card(opponent[2], 3);//对方第三张牌一定与其他两张牌相同
		if (flag == -1)break;
		if (flag == n - 1) //自己出的三带是位于最后的几张牌
		{
			cout << myself[0].card << ' ' << myself[1].card << ' ';  //带上第一、二张牌即可
			for (int k = 0; k < 3; ++k)
				cout << myself[flag - k].card << ' ';
			cout << endl;
		}
		else {
			cout << myself[0].card << ' '; //带上第一张牌
			for (int k = 0; k < 3; ++k)
				cout << myself[flag - k].card << ' ';
			cout<< myself[n - 1].card << endl; //带上最后一张牌
		}
		return;
	}
	case straight: {
		if (opponent[0].card == "2")break; //对方已经连到2
		if (!find_straight())break;  //未能找到顺子压住对方
		for (int i = 0; i < m; ++i)
			cout << deal_myself[i].card << ' ';
		cout << endl;
		return;
	}
	case consecutive:
	case plane:
	case four_and_two: {
		if (m == 6) //对方四带两张牌
		{
			int flag = find_card(opponent[2], 4);
			if (flag == -1)break;
			if (flag == n - 1) //自己出的四带是位于最后的几张牌
			{
				cout << myself[0].card << ' ' << myself[1].card << myself[2].card << endl;  //带上第一、二、三张牌即可
				for (int k = 0; k < 4; ++k)
					cout << myself[flag - k].card << ' ';
				cout << endl;
			}
			else {
				cout << myself[0].card << ' '; //带上第一张牌
				for (int k = 0; k < 4; ++k)
					cout << myself[flag - k].card << ' ';
				cout << myself[n - 1].card << endl; //带上最后一张牌
			}
			return;
		}
		else  //对方四带两对牌
		{
			Card tmp; //存放对方四张相同牌的牌面
			if (opponent[3].card == opponent[4].card)  //四张相同的牌在中间
				tmp = opponent[3];
			else if (opponent[0].card == opponent[1].card)  //前四张牌相同
				tmp = opponent[0];
			else tmp = opponent[4];  //后四张牌相同
			int flag = find_card(tmp, 4);
			if (flag == -1)break;
			int pair_first = -1, pair_second = -1;  
			find_pair(pair_first, pair_second);
			if (pair_second == -1)break; //自己手上没有两对对子可以带
			if (pair_first < flag)
			{
				cout << myself[pair_first].card << ' ' << myself[pair_first + 1].card << ' ';
				for (int k = 0; k < 4; ++k)
					cout << myself[flag - k].card << ' ';
				cout << myself[pair_second].card << ' ' << myself[pair_second + 1].card << ' ';
			}
			else {
				for (int k = 0; k < 4; ++k)
					cout << myself[flag - k].card << ' ';
				cout << myself[pair_first].card << ' ' << myself[pair_first + 1].card << ' ';
				cout << myself[pair_second].card << ' ' << myself[pair_second + 1].card << ' ';
			}
			cout << endl;
			return;
		}
	}
	default:
		break;
	}
	if (opponent_card == bomb)
	{
		if (myself[0].card == "JOKER"&&myself[1].card == "joker")
			cout << myself[0].card << ' ' << myself[1].card << endl;
		return;
	}
	else {
		Card tmp;
		tmp.n = -1;
		int flag = find_card(tmp, 4);
		if (flag == -1)
		{
			cout << "YAO BU QI" << endl;
			return;
		}
		for (int k = 0; k < 4; ++k)
			cout << myself[flag - k].card << ' ';
		cout << endl;
		return;
	}
	cout << "YAO BU QI" << endl;
}